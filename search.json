[{"title":"2021_buuctf_pwn","date":"2021-05-30T14:35:03.000Z","url":"/2021/05/30/2021-5-30/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["heap","/categories/heap/"]],"content":"PWN：pwnpwn.zip 运行环境为ubuntu18.04，libc-2.27 题目分析不用想保护全开，经典菜单题 菜单有malloc、free、edit、show功能，有一个offbyone漏洞，可以尝试三明治攻击构造两个指向同一块chunk的指针 思路 先将大小为0x90的tcachebins填满 然后构造0x90（free）—0x90（in_use）—0x90（free）三明治布局 利用offbyone、unlink得到一个0x1B0大小的堆块包含中间的0x90 将第一个堆块申请出来，就可以泄露地址 再申请一个堆块就得到两个指向同一块chunk的指针 通过攻击tcachebins来写malloc_hook为one_gadget 申请堆块获取shell 坑点 offbyone漏洞一开始没发现，后续仔细分析了一下发现很简单，一开始没静下心来分析 不清楚题目的libc版本，题目只给了libc.so 注意最后一个堆块要额外申请一个小堆块，防止与top chunk合并 题外话：题目还是挺好的（对于本菜鸡来说），就是比赛当天有事导致题目没怎么看，准备赛后复现，然后第一道堆题环境是2.23版本的，不太熟悉就没怎么看了，主要是第二道堆题（现在写的），offbyone漏洞一开始没发现，看大佬的博客发现漏洞后（就是当申请的堆块的size的倒数第四位为一，就差不多行了刚好8满足需求）就感觉可以做出了，自己尝试了一下，确实发现没什么难度，这类题目做过类似的所以挺简单的，文章末尾会附上一些大佬的wp和一些例题 exp 参考博文：   推荐例题： "},{"title":"2021_360ctf_pwn","date":"2021-05-27T14:15:11.000Z","url":"/2021/05/27/2021-5-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["heap","/categories/heap/"]],"content":"PWN：lonelysolf题目涉及知识点lonelywolf.zip 先讲讲本次题目所涉及的知识点（我一开始的知识盲区）：tcache_perthread_struct结构体，先看看源代码的样子 可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。这里写了一个简单的实验，通过调试来理解tcache_perthread_struct结构体的工作方式。 堆调试实验一程序代码： 调试截图（这里程序运行到了释放最后一个chunk的位置）可以看看bin里的内容 再看看堆块的情况，可以看到它的第一个chunk（tcache_perthread_struct结构体）的位置（0x555555559000） 可以看一下tcache_perthread_struct结构体里的内容 这里可以验证字符数组里存放的就是tcachebins的计数器里的值，然后可以看看指针数组里存放的是不是释放后堆块的地址 可以发现指针数组里存放的就是是释放后堆块的地址，通过这个实验可以了解tcache_perthread_struct结构体的管理结构，这个是这次题目的攻击对象，然后在介绍攻击方式：tcachebins里的double free。 这里看看tcachebins链表的结构： 再来看一下free中是怎么处理添加chunk到tcache的，不同于malloc_libc_free对外的接口不直接处理tcache，而是在_int_free这个模块内部例程中处理有关tcache的操作 可以看到这就是tcache的double free检测机制，判断条件就是tcache_entry的key指针（堆块的bk指针位置）是否等于tcache（通过接下来的实验可以发现就是堆初始化的时候申请的第一个chunk的数据地址），这里写了一个简单的tcache的double free的实验。 堆调试实验二程序代码： 这个是第一次free的情况 可以看到tcache_entry的key指针（堆块的bk指针位置）就是堆初始化的时候申请的第一个chunk的数据地址，接下来我们通过填充字节’A’来破坏它 这个是填充字节之后的情况，可以看到bk指针也就是key指针已经被我们修改了，这样的话我们再次释放就可以绕过检测了，接下来可以再次释放就可以达到double free的目的 目的达到，而且这个还是2.31相对高版本的glibc（注：tcache_perthread_struct结构体在2.31版本有些不一样，可以自己通过上面的第一个实验来比较，这里就略过） 题目分析 漏洞分析： 经典的菜单题目，可以看到它我们每次malloc的大小限制到了fastbins范围内，而且每次malloc都会清空上一个的chunk指针（这里限制了我们填充tcachebins的方法），但是free不会清空，这里就有一个UAF漏洞，然后我们的目的是伪造unsortbins（第一个堆块刚好满足条件，而且可以修改tcachebins的计数器），然后free，泄露地址（原理：当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址） 思路有了，先重新构造函数 通过double free达到任意地址读写，同时泄露堆块的地址（用来计算堆初始化的时候第一个chunk的地址，通过第一个chunk达到攻击的目的） 然后就可以修改free chunk的fd指针使其指向堆初始化的时候第一个chunk的地址，然后就可以申请到堆初始化的时候第一个chunk了 要将当前的chunk释放到unsortedbin里，就要先将tcachebins填满，这里可以通过修改第一个堆块的值将tcachebins伪造成满的（根据第一个实验就很容易理解了） 接下来就好办了 exp： 参考博文：   "}]