[{"title":"2021_天翼杯_pwn","date":"2021-09-23T15:44:35.000Z","url":"/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"写在前面这个比赛难度还是比较大的，才出了一道pwn题，总共就看了两道题目，写点笔记记录一下 chaos题目附件 题目分析及漏洞利用 前面是有一点代码审计的感觉，不过还是比较简单的，花点时间就好了，后面就是常规的菜单题目。chunk其实就是简单的单链表结构，释放的时候就是简单的脱链。 在申请堆块的时候存在溢出，可以修改到size部分，然后配合编辑就可以修改chunk_addr，再编辑就达到任意地址写。 同理也可以达到任意地址读的操作，也是修改chunk_addr指针部分 exp"},{"title":"ret2dlresolve学习笔记","date":"2021-09-22T15:51:04.000Z","url":"/2021/09/22/ret2dlresolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["stack","/tags/stack/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["pwn","/categories/pwn/"]],"content":"写在前面本篇文章只是一些学习记录、打卡，很大部分是摘自其他大佬博客，还有一些自己的东西，文末会贴上链接，练习建议自己独立完成。 前置知识在Linux中，程序使用_dl_runtime_resolve(link_map,reloc_offset)来对动态链接的函数进行重定位。而ret2dlresolve攻击的核心就是控制相应的参数及其对应地址的内容，从而控制解析的函数。 延迟绑定需要了解3个结构以及他们之间的关系 程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。 这时候，就出现了延迟绑定技术，我们通过plt表（过程链接表），在第一次调用函数的时候，来确定函数的地址，把函数的实际地址存储在got表相对的偏移处。 试想一下，在这个过程中，当我们第一次调用函数，要向got表写入函数真实地址的时候，我们是不是需要一个管理的工具？这个管理的工具就是_dl_runtime_resolve()函数。函数需要两个参数，一个是要被绑定的函数所在的模块，一个是要被绑定函数的符号名。 函数原型：_dl_runtime_resolve(link_map,reloc_arg) 注：got表实际上是分为.got表和got.plt表，got.plt表（全局函数偏移表）中存放的是动态链接库函数，.got表（全局变量偏移表）里面的偏移主要是全局变量。我们在这里讨论的是got.plt表。 .got.plt表的前三项的含义分别如下: 1.got[0],第一项保存的是”.dynamic”段的地址，这个段描述了本模块动态链接相关的信息； 2.got[1],第二项保存的是本模块的ID； 3.got[2],第三项保存的是_dl_runtime_resolve()函数的地址。 且我们需要知道.got.plt前三项的特殊用途 address of .dynamic link_map dl_runtime_resolve _dll_runtime_resolve函数的2个参数 _dll_runtime_resolve函数的运行过程 练习小练习1参考博客： ret2dlresolve超详细教程(x86&amp;x64)_77Pray的博客-CSDN博客 先编译以下代码，逐步利用_dl_fixup函数最后get shell 首先是先栈迁移到bss段，再手动调用plt[0]，解析write函数，把命令打印出来，我们只需提前push reloc_arg（push 20h）即可完成利用 对应的是这一句 has exp 成功打印字符串 小练习2这一步我们控制好reloc_arg的大小，使reloc的位置落在可控地址(bss段)内，在bss段手动伪造出reloc，即伪造.rel.plt中关于write的内容，从而可以控制它的r_info 对应这一句 .rel.plt节是用于函数重定位，**.rel.dyn**是用于变量重定位 下面是rel的结构体定义 exp 小练习3这一步我们控制好reloc中的r_info，使sym落在可控地址内，从而伪造sym，从而可以控制它的st_name（偏移） 对应这两句 .dynsym节包含了动态链接符号表。ELF32_Sym[num]中的num对应着**ELF_R_SYM(Elf32_Rel-&gt;r_info)**。根据定义， ym的结构体如下（大小为0x10） has 注意16字节对齐 exp 小练习4相信到了这一步，对于接下来要做什么已经很清楚了，既然在上一步我们能控制st_name，那接下来自然是伪造st_name，从而可以控制字符串表 对应这一句 exp 大佬博客ret2dlresolve利用方法_九层台-CSDN博客 栈溢出之ret2dlresolve学习 - FreeBuf网络安全行业门户 ret2dlresolve超详细教程(x86&amp;x64)_77Pray的博客-CSDN博客 [新手向]ret2dl-resolve详解 PWN——ret2dl_resolve - Riv4ille - 博客园"},{"title":"暑假刷题笔记","date":"2021-09-21T09:43:20.000Z","url":"/2021/09/21/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"水一篇博客，这个是题库 题目附件提取码: r2en [V&amp;N2020 公开赛]simpleHeap远程是libc2.23版本的，但是我想试试用libc2.27版本来看看可不可以打通（有点难度），亲测能行 题目分析有一个offbyone漏洞但是限制了我们的chunk在0x6f范围内，想要通过unsortedbins泄露地址需要将tcachebins填充，但是限制了chunk大小，所以不能简单的释放就能填充，可以考虑overlapping。 思路 构造三个堆块，第一个堆块用来修改第二个堆块的size，使得第二个堆块覆盖第三个堆块的头，用来控制第三个堆块 释放第三个堆块，泄露chunk_head地址，通过tcache_perthread来泄露基地址，写free_hook为system，通过释放带有/bin/sh的堆块来getshell 坑点 原题的攻击方法是基于libc2.23的，本地的版本是libc2.27的，可以说攻击方式完全不同，不过通过这个题目更了解libc2.27的堆管理情况 一开始想了很多方法，都没成功，版本不同对题目的难度加大，不够学到了很多，对2.27版本有进一步的认识 0ctf_2016_warmup题目分析 栈溢出,突破点就在于alarm函数了。alarm函数有一个特性，如果多次调用alarm，那么alarm就会返回前一个alarm开始到现在，还剩下多长时间。比如，第一次alarm(10)，然后过来2s，我们又调用alarm(1234)，那么第二次的alarm返回值eax为10s-2s=8s。 exp 0CTF_2017_babyheap题目分析一个简单的菜单题，有增删改查功能，编辑功能存在堆溢出 思路 通过堆溢出来实现堆块重叠 通过堆溢出改写堆块大小，通过unsortedbins来泄露libc地址 利用fastbin attack改malloc hook为realloc hook（在malloc hook-8的位置），改realloc为one_gadget，通过不断尝试realloc的正确偏移为10 exp ciscn_2019_sw_1题目分析 格式化字符串漏洞，但是只有一次调用 思路 这里利用到了fini_array劫持技术，可以使程序再次运行一次 然后改printf‘s got为system’s plt表 输入/bin/sh,拿到shell exp hitcontraining_playfmt题目分析 一个无限循环的格式化字符串漏洞 思路 利用ebp的双重指针来修改栈上的数据 改返回地址为system，参数布置在栈上 exp get_started_3dsctf_2016题目分析简单栈溢出，打卡题目 exp not_the_same_3dsctf_2016题目分析简单的栈溢出，布置好参数传递就行 exp babyfengshui_33c3_2016题目分析 思路 风水布置堆块，达到任意地址读写 改free的got表为system 释放包含‘bin/sh\\0’的堆块get shell exp 2021_强网杯_NO_output题目分析 满足两个条件就可以进行栈溢出了，一个是检测字符串是否相等，可以用\\x00截断绕过，还要满足的条件是signal 浮点异常的信号才能触发漏洞，利用ret2dlresolve就行，可以参考我的学习笔记 exp C语言编程技巧-signal(信号)  rec_33c3_2016rec_33c3_2016(堆栈不平衡) 题目分析 Polish里有栈不平衡会拔高栈帧 思路 通过栈上残留地址，leak基地址 利用栈不平衡，不断拔高栈帧，让栈降低到合适的位置，然后就可以通过push向栈中写数据 v2函数指针调用我们的函数 exp sctf_2019_easy_heap(改)题目分析经典的offbyone漏洞，程序稍微改了点，希望能用2.31版本来测试，之前使用2.27版本打的这倒道题目，因为2.31版本对于unlink多了两个检测，一个是检测释放chunk的pre_size是否等于要合并chunk的size大小，还有一个是检测要合并的chunk是否是自连，目前我找到的方法有自己伪造堆块头，利用offbynull漏洞来unlink，还有个是利用large bin的残留信息。 改动如下，因为没有输出所以有一定的难度 思路 通过泄露的堆块地址来伪造堆块头 利用offbynull来使堆块与我们的fuke堆块合并 这样就可以照成堆块复用，导致任意地址读写，先将shellcode注入到rxw段上，可是题目没有输出堆块的功能 可以使用三个堆块复用，利用double free，一个chunk在tcache bins，一个在unsorted bins里（这个要构造比较特殊，需要用到切割unsorted bin来实现），因为main_arena+96的位置和malloc hook的位置很近，只需修改一个字节就好，改malloc hook为shellcode地址 大概成功以后是这个样子 这样申请两个0x100的堆块就可以改到malloc hook里的指针 exp 360chunqiu2017——smallest题目分析 2017 429 ichunqiu ctf smallest(pwn300) writeup_jmp esp-CSDN博客 思路 通过srop来控制寄存器 注意要保持read持续输入 exp 2018_breakfast题目分析 一个uaf，一个任意地址读，堆打卡题，简单直接撸代码 思路 leak free的地址，算出libc基地址 改free hook为system 释放包含‘/bin/sh\\x00’的堆块get shell exp music题目分析格式化字符串漏洞和栈溢出 exp ichunqiuyiqing_borrowstack题目分析 思路 利用rop链控制寄存器来进行攻击，首先需要泄露地址 然后就是常规rop攻击，这里我用到了ret2csu 坑点可以说之前有一个地方困扰了我很久，就是经常栈迁移的时候程序经常dang了，这次我理解了，因为bss段上面一块区域是一个只有只读权限的内存空间，当我们进行系统调用的时候往往需要压栈的操作，这种操作往往会使的栈不断地拔高，一旦栈帧指向了只有只读权限的内存空间的时候就会报错，因为对栈帧的操作往往需要有写的权限，这也是我经常忽视的地方，所以栈迁移的时候尽量迁移到bss段后面 exp Dream题目分析存在格式化字符串漏洞，可以用来leak地址，编辑堆块的size可控，可以造成堆溢出，还有一个uaf漏洞，可以达到任意地址读写 思路 利用格式化字符串漏洞leak地址 利用fastbin attack改malloc hook为realloc hook（在malloc hook-8的位置），改realloc为one_gadget exp ichunqiuyiqing_excited题目分析堆块里存在指针，而且有uaf漏洞，flag文件读取到内存里了，可以通过特殊布局利用uaf来将指针指向flag的位置，再读取打印 exp ichunqiuyiqing_interested题目分析 存在格式化字符串漏洞leak地址，UAF漏洞，堆打卡 exp SCP_Foundation题目分析存在uaf漏洞，堆块存在指针，有show、add、free功能，flag已经读取到内存中了，直接把堆块里的指针改成对应内存快的指针就可以读取flag了 exp axb_2019_heap题目分析存在格式化字符串漏洞leak地址，没有show功能，只能申请0x80以上的堆块。有一个offbynull漏洞。 涉及知识点unlink 本次攻击是将chunk0指向数据的指针当作指向伪造chunk头的指针，FD-&gt;bk、BK-&gt;fd就是我们伪造的指针，他们都同时指向bss段上chunk0的指针，可以将bss段上的指针改成BK-&gt;fd。这样就可以控制堆块指针达到任意地址读写 exp"},{"title":"2021_长城杯_pwn","date":"2021-09-21T09:07:43.000Z","url":"/2021/09/21/2021-9-20/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"中秋放假打了下长城杯，干了两pwn，战绩不错，后面复现了企业组的pwn3，写个博客记录下。 K1ng_in_h3Ap_I题目附件 题目分析 菜单题目，没有show功能，漏洞还是挺多的,uaf和offbyone随便一个都够打，有leak3字节的地址就省去爆破倒数第四位的功夫了，打stdout来泄露地址，改malloc hook为one_gadget来拿shell。可以参考这位师傅的博客： 思路通过风水布置堆块使得bin里的结构达到这个效果 此时可以利用题目给的偏移计算stdout地址，部分修改fd指针，将堆块申请到附近。 然后将缓冲区base地址指针改小就可以泄露指针范围的地址 改完以后是这个样子 然后就会输出该指针范围内的东西，最后面调用的就是_IO_new_do_write 得到地址就可以打malloc，然后用realloc调偏移 IO FILE系列的相关知识可以看看这位大佬的博客： exp K1ng_in_h3Ap_II题目附件 题目分析 菜单题功能很全但是malloc的chunk限制了大小，free后指针没有清空，存在uaf漏洞。开了沙盒保护。 思路确实思路挺简单的，通过攻击 tcache_perthread_struct可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。 通过uaf将该chunk申请出来 然后将结构体里的counts数组都填充成\\x07,也就是tcachebins存放chunk的最大范围，这样我们释放tcache_perthread_struct然，就可以得到地址了。 然后控制这个结构体就可以达到任意地址写。 然后劫持free hook为setcontext+53。 在释放的堆块里布置对应的寄存器。这样就可以通过rdi（也就是我们释放的堆块）来控制寄存器。然后就orw拿到flag exp ~XLVXR5H9H6%5BQ%7DNON.png “”) hellopwn（企业组）题目附件 题目分析 题目情况大概就是这样了，没有打印功能，限制了编辑和释放堆块的次数，chunk的大小范围控制在了large bin范围内。在释放堆块的时候，指针未清空，存在uaf漏洞。 思路先通过magic打stdout泄露地址，和之前的方法一样，把缓冲区base地址的指针改小就可以了，然后就是通过large bin attack来完成后续的操作，下面讲一下。参考师傅的博客： 在glibc2.31版本里常规的large bin attack被封杀了，但是large bin attack还有另一个分支可以利用 可以看到在glibc2.32版本里加了一个链表完整性的检测，但是他封杀的只是其中一个分支，还有一个分支可以利用，可以达到任意地址写一个我们可控的堆块地址。 通过控制large bin里的bk_nextsize来达到任意地址读写，再申请比unsorted bin还大的chunk来触发漏洞（unsorted bin里chunk的size要小于large bin里的size） 大概堆块布局的这样的 通过uaf控制large bin里的chunk，改写large bin里的chunk的bk_nextsize,来达到任意地址写一个堆块地址。 再申请一个大堆块触发漏洞 我们来看一下tcache部分的源码 然后我们的目的就是将覆写mp_.tcache_bins的值为一个很大的地址，使得large bin大小范围的chunk被释放也会放到tcache bin里，后面就简单了，因为申请tcache bin的chunk不会检测size是否合法，所以我们就可以利用uaf达到任意地址写的效果。 exp"},{"title":"2021_redhet","date":"2021-09-21T08:55:49.000Z","url":"/2021/09/21/2021-redhet/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"]],"categories":[["pwn","/categories/pwn/"]],"content":"题目附件 manager题目分析一个菜单题，有Insert、Delete、Show功能，通过二叉树管理堆块 Insert这里写了一点insert的流程（根节点主要画了右子叶，左子叶原理都是一样的） 总结来说，小的往左边放，大的往右边放，找到相等的就不放 Delete大概可以分为四种情况 清空的堆块没有左子叶，有右子叶 清空的堆块没有右子叶，有左子叶 清空的堆块没有右子叶，没有左子叶 清空的堆块有右子叶，有左子叶，这个情况有点麻烦，但同时漏洞也出现在这里 漏洞出现在第四种情况 当右子叶的子叶存在左子叶时，就会释放该节点中我们自己申请的堆块，而最后面又会释放堆块（包括我们在里面申请的堆块），所以这种情况下就会出现double free的情况，布局如下： 这里有一些当时部分代码的分析情况可以参考（随便看看就好） show通过中(根)序遍历来显示堆块信息 解题思路 通过特殊布局达到double free效果 通过double free来利用tcache bins来实现任意地址读写 改free_hook为system，通过释放包含‘/bin/sh’的堆块来getshell 坑点 本题为旧版本的glibc-2.27,新版本的包含tcache bins的double free检测机制(可以参考之前写的360的lonelywolf)，一开始在我的Ubuntu上折腾了好久，后面才考虑到可能是glibc版本原因，用patchelf来修改文件的glibc，文末会有相应的教程链接 我觉得最困难的不是漏洞利用，而是代码审计，需要有一定的耐心一步步地分析完 exp ![](2021-redhet/Untitled 7.png “”) patchelf相应教程： parser题目分析 正常地接受字节，无溢出进入循环 主要是这个函数，会对数据进行筛选，过滤 发现漏洞，但需要一定的条件。下面是我对这个程序的分析过程 解题思路 通过格式化字符串泄露地址 改malloc_hook为one_gadget 利用%100000c触发malloc/free，劫持程序控制流 exp "},{"title":"2021祥云杯_pwn","date":"2021-08-27T04:02:39.000Z","url":"/2021/08/27/2021-8-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PassWordBox_FreeVersionPassWordBox_FreeVersion.zip 题目分析 2.27版本的offbynull，有一字长的加密，一开始没想到直接填充/X00就可以leak加密的密钥，无脑爆破，写了个小程序，把密钥爆出来了。贴个源码。 然后就是常规操作，unlink后，达到任意地址读写，改malloc hook为one gadget，申请堆块触发one gadget。可以参考我之前写的 2021_BUUCTF&amp;DASCTF_pwn exp JigSaw’sCageJigSaw’sCage.zip 题目分析 存在溢出，改v2的值，触发mprotect，使得heap区域可执行。 因为有text功能，可以执行堆块里的指令，然后就是写汇编布置参数调用execve(“/bin/sh”)来拿shell exp PassWordBox_ProVersion（赛后复现）PassWordBox_ProVersion.zip 题目分析存在uaf，但是size范围限制在了large bin大小，2.31版本常规large bin attack方法是被修复的，但是还是存在可以利用的漏洞 house of banana - 安全客，安全资讯平台 官方给的思路应该是house of banana，向_rtld_global 里伪造结构体，手法和house of banana一样，主要是一些参数的布置不太了解，当时没复现出，赛后硬调出来了。附上poc，可以调一下。 大佬博客： poc exp 网上还有一种方法，是修改mp_.tcache_bin，使得大于0x408大小的堆块也能在tcache中，这种方法使得我们的攻击更为简单。 从祥云杯PassWordBox_ProVersion看GLIBC2.31 LargeBin Attack_黑客技术 只需要将这里改大就可以使得大于0x408大小的堆块也能在tcache中（利用large bin attack）。主要是这一个，可以看一下tcache部分的代码。 后续就是attack tcache bin，就挺简单了，改free hook 为system exp note(赛后复现)note.zip 题目分析 存在scanf格式化漏洞，有申请堆块的功能，同时会leak堆块地址信息,还有show的功能，没有free 解题思路 通过格式化字符输入修改top chunk的大小（注意地址需要页对其），申请比top chunk大小还大的chunk来将top chunk放入到unsorted bin里来leak地址 然后伪造file结构体（包括vtable结构），将_IO_2_1_stderr_的_chain改成我们伪造的file结构体，在程序结束的时候会调用_IO_flush_all_lockp函数，这个函数最初的目的是为了保留数据不丢失，如果缓冲区还残留数据，就会调用_IO_OVERFLOW来刷新缓冲区，这样的话，我们伪造的file结构体中缓冲区的长度fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base就必须大于0，还有一个检测就是mode要小于等于0 exp 还有一种方式leak地址通过改输出stdout的_IO_write_base使得缓冲区存在数据。 最终执行_IO_do_write来调用系统调用write输出输出缓冲区 IO FILE之fwrite详解："},{"title":"2021_7_BUUCTF&&DASCTF","date":"2021-08-02T09:21:47.000Z","url":"/2021/08/02/2021-7-31/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"],["密码pwn","/tags/%E5%AF%86%E7%A0%81pwn/"]],"categories":[["pwn","/categories/pwn/"]],"content":"BUUCTF&amp;&amp;DASCTFBUUCTF&amp;DASCTF_pwn.zip 进行了长达两天的ctf比赛，第一天从上午10点在电脑面前坐到了晚上十一二点，出了两pwn和一个misc，第二天比较人性化就放了一个pwn题目，一个密码pwn，比较恶心，那个密码还不太会，不过给了密码后面乱杀。总之累死👴了，不过还是挺值的。虽然没有拿到前三血，但ak了，发挥超常，还出了一个misc，一共出了4题，战绩不错。第一次有一种意犹未尽的感觉，题目也挺不错的，下面就分享下解题思路。 pwnEasyheap题目分析一个沙盒堆题，常规的菜单题，保护全开，禁用了execve，得用orw来获取flag 漏洞分析：strup函数比较特殊，这使得我们之前输入的size与实际申请的size有点不一样，这同时也是我们利用的地方。输入size的大小远超于实际输入的字符串，使得我们edit堆块的时候，写入的范围变大，造成溢出。 思路 通过编辑溢出，造成堆块重叠，达到任意地址读写 leak libc基地址，将我们的orw的shellcode注入到rwx段上 然后改malloc hook为shellcode所在地址即rwx段，申请堆块触发shellcode exp realNoOutput题目分析一个典型的菜单堆题 看起来这个程序很完美，一些像offbynull、uaf、溢出漏洞都规避了，似乎没啥子问题，我一开始也想了很多种方法，尝试了一下午，不断地碰壁，本来是打算放弃的，但是当我偶然间查看堆块指针数组的时候发现了一个很奇怪的事 可以看到这里的堆块1指针变为了size（原本是堆块指针的），可以说这里是这个题目的转折点，也是我一直忽略的地方————size数组和堆块指针数组越界了 可以看到数组大小都是8字长的，但是我们的申请的范围是0-9，需要10字长，这会造成我们的指针数组里的数据会被改成size，这个会有什么用呢，因为每次修改、展示、删除堆块的时候都会有两个判断，通过这两个判断会将局部变量buf（栈上的数据）修改成堆块指针，发现就算是清空堆块的时候都不会将栈上的堆块指针清空，所以这里用到了栈的知识。我们每次调用函数结束的时候都会释放函数栈帧，所谓的释放不是清空，而是单纯的不使用这一块栈帧直到下一次调用函数的时候，栈帧里的数据都会一直保持不变。然后要使得局部变量buf上的指针不变则需要回避这个判断 这个就要用到我们的数组越界了，只需要释放chunk，再将释放后的指针位置越界改成size（chunk必须在第0、1的位置），就可以保证该位置不为空，而且不会修改到局部变量buf上的指针，达到UAF的效果，这道题是非预期，后面那道题方法有点类似，也用到栈上的残留的数据 思路 通过上面所讲的栈帧残留可以达到UAF的效果 通过UAF造成堆块重叠，达到任意地址读写 改free hook 为system地址，释放包含’/bin/sh’的堆块，get shell exp canary题目分析 输入用户名和密码，就是常规的栈题，用到的方法和pwn2的类似，利用上一个栈帧残留的信息来leak地址，因为字符串是以\\x00作为截断符的，所以覆盖了就可以leak地址了 思路 通过overflow将栈帧的数据结构进行改写 利用改写后残留的数据信息，可以leak栈上的地址 返回地址改后门函数地址就行 exp miscred_vs_blue 思路nc题，挺适合pwn👴的，直接撸代码，一把梭 exp "},{"title":"2021_蓝帽杯半决赛pwn","date":"2021-06-06T12:54:33.000Z","url":"/2021/06/06/2021-6-6/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"]],"categories":[["pwn","/categories/pwn/"]],"content":"hangmanhangman.zip 题目分析 题目逻辑大概是先输入一段字符串，生成一段等大小的‘*’（用局部变量v12存放），然后会让你输入一个字符，判断字符是否存在字符串中，如果是则统计该字符个数（当所有字符个数等于原字符串长度时，会有一个格式化字符串漏洞）同时局部变量v12的相应位置（字符串中的相同位置）会变成该字符，程序会进行四次game，也就是说我们有四次利用的机会 思路 先利用格式化字符串泄露libc基地址 然后改malloc为one_gadget 利用%100000c触发malloc/free，劫持程序控制流 坑点 和堆的知识结合利用，通过printf调用malloc 程序稍微有点长，变量会有一点多，需要慢慢分析 题外话，第一次打线下赛，感觉还是很不错的，收获了许多涨了许多知识，了解到了一些平时没见过的知识点，可以说是收获满满 exp covercover.zip 题目分析 没开pie 这里导致了我们的code段可写，说明可能需要修改code段里的数据，方向大致朝这个方向想 这里跳过if判断使得程序不会跳出，目前为止是一个正常的程序，但是通过gdb调试发现if判断后会有一段异常的汇编代码 这里输入的是b’’*4+b’66’，可以看到程序运行到这里是将0xffffffff地址的最后一个字节的数据改成0x66，因为之前分析了code可写，那么可以考虑将put的plt表里的got地址跳转地址修改成system的got地址,可以看看got表的数据 system的got刚好就在putsgot的下面，所以只需要将最后一个字节0x20改成0x24就可 put的plt表中jmp后的got表的最后一个字节为ff需要加2使得最后一个字节为20，改20为24就可 exp "},{"title":"2021_BUUCTF&DASCTF_pwn","date":"2021-05-30T14:35:03.000Z","url":"/2021/05/30/2021-5-30/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PWN：pwnpwn.zip 运行环境为ubuntu18.04，libc-2.27 题目分析不用想保护全开，经典菜单题 菜单有malloc、free、edit、show功能，有一个offbyone漏洞，可以尝试三明治攻击构造两个指向同一块chunk的指针，还有一种方法就是利用overlapping来攻击 方法一思路 先将大小为0x90的tcachebins填满 然后构造0x91（free）—0x90（used）—0x91（used）三明治布局 利用offbyone修改第三个堆块的presize和pre_inuse位，利用unlink得到一个0x1B0大小的堆块包含中间的0x90 将第一个堆块申请出来，通过第二个堆块（used）就可以泄露地址 再申请一个堆块就得到两个指向同一块chunk的指针即第二个堆块 通过攻击tcachebins来写malloc_hook为one_gadget 申请堆块获取shell 坑点 offbyone漏洞一开始没发现，后续仔细分析了一下发现很简单，一开始没静下心来分析 不清楚题目的libc版本，题目只给了libc.so 注意最后一个堆块要额外申请一个小堆块，防止与top chunk合并 题外话：比赛当天有事导致题目没怎么看，准备赛后复现，然后第一道堆题环境是2.23版本的，不太熟悉就没怎么看了，主要是第二道堆题（现在写的），offbyone漏洞一开始没发现，看大佬的博客发现漏洞后（就是当申请的堆块的size的倒数第四位为一，就差不多行了刚好8满足需求）就感觉可以做出了，自己尝试了一下，确实发现没什么难度，这类题目做过类似的所以挺简单的，文章末尾会附上一些大佬的wp和一些例题 exp 方法二思路 构造三个堆块0x21（used）-0x91（used）-0x21（used） 然后利用offbyone修改第二个堆块的大小，使得第二个堆块的大小刚好覆盖第三个堆块（也就是将第二个堆块） 释放第二块堆块，再申请0x91大小的堆块，这样就可以通过第三个堆块泄露地址 再申请一个0x21堆块就得到两个指向同一块chunk的指针即第三个堆块 写free_hook为system地址，释放带有/bin/sh的块获取shell exp 参考博文：    推荐例题： "},{"title":"2021_360CTF_pwn","date":"2021-05-27T14:15:11.000Z","url":"/2021/05/27/2021-5-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PWN：lonelysolf题目涉及知识点lonelywolf.zip 先讲讲本次题目所涉及的知识点（我一开始的知识盲区）：tcache_perthread_struct结构体，先看看源代码的样子 可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。这里写了一个简单的实验，通过调试来理解tcache_perthread_struct结构体的工作方式。 堆调试实验一程序代码： 调试截图（这里程序运行到了释放最后一个chunk的位置）可以看看bin里的内容 再看看堆块的情况，可以看到它的第一个chunk（tcache_perthread_struct结构体）的位置（0x555555559000） 可以看一下tcache_perthread_struct结构体里的内容 这里可以验证字符数组里存放的就是tcachebins的计数器里的值，然后可以看看指针数组里存放的是不是释放后堆块的地址 可以发现指针数组里存放的就是是释放后堆块的地址，通过这个实验可以了解tcache_perthread_struct结构体的管理结构，这个是这次题目的攻击对象，然后在介绍攻击方式：tcachebins里的double free。 这里看看tcachebins链表的结构： 再来看一下free中是怎么处理添加chunk到tcache的，不同于malloc_libc_free对外的接口不直接处理tcache，而是在_int_free这个模块内部例程中处理有关tcache的操作 可以看到这就是tcache的double free检测机制，判断条件就是tcache_entry的key指针（堆块的bk指针位置）是否等于tcache（通过接下来的实验可以发现就是堆初始化的时候申请的第一个chunk的数据地址），这里写了一个简单的tcache的double free的实验。 堆调试实验二程序代码： 这个是第一次free的情况 可以看到tcache_entry的key指针（堆块的bk指针位置）就是堆初始化的时候申请的第一个chunk的数据地址，接下来我们通过填充字节’A’来破坏它 这个是填充字节之后的情况，可以看到bk指针也就是key指针已经被我们修改了，这样的话我们再次释放就可以绕过检测了，接下来可以再次释放就可以达到double free的目的 目的达到，而且这个还是2.31相对高版本的glibc（注：tcache_perthread_struct结构体在2.31版本有些不一样，可以自己通过上面的第一个实验来比较，这里就略过） 题目分析 漏洞分析： 经典的菜单题目，可以看到它我们每次malloc的大小限制到了fastbins范围内，而且每次malloc都会清空上一个的chunk指针（这里限制了我们填充tcachebins的方法），但是free不会清空，这里就有一个UAF漏洞，然后我们的目的是伪造unsortbins（第一个堆块刚好满足条件，而且可以修改tcachebins的计数器），然后free，泄露地址（原理：当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址） 思路有了，先重新构造函数 通过double free达到任意地址读写，同时泄露堆块的地址（用来计算堆初始化的时候第一个chunk的地址，通过第一个chunk达到攻击的目的） 然后就可以修改free chunk的fd指针使其指向堆初始化的时候第一个chunk的地址，然后就可以申请到堆初始化的时候第一个chunk了 要将当前的chunk释放到unsortedbin里，就要先将tcachebins填满，这里可以通过修改第一个堆块的值将tcachebins伪造成满的（根据第一个实验就很容易理解了） 接下来就好办了 exp： 参考博文：   "}]