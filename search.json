[{"title":"2021_蓝帽杯半决赛pwn","date":"2021-06-06T12:54:33.000Z","url":"/2021/06/06/2021-6-6/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"]],"categories":[["stack","/categories/stack/"]],"content":"hangmanhangman.zip 题目分析 题目逻辑大概是先输入一段字符串，生成一段等大小的‘*’（用局部变量v12存放），然后会让你输入一个字符，判断字符是否存在字符串中，如果是则统计该字符个数（当所有字符个数等于原字符串长度时，会有一个格式化字符串漏洞）同时局部变量v12的相应位置（字符串中的相同位置）会变成该字符，程序会进行四次game，也就是说我们有四次利用的机会 思路 先利用格式化字符串泄露libc基地址 然后改malloc为one_gadget 利用%100000c触发malloc/free，劫持程序控制流 坑点 和堆的知识结合利用，通过printf调用malloc 程序稍微有点长，变量会有一点多，需要慢慢分析 题外话，第一次打线下赛，感觉还是很不错的，收获了许多涨了许多知识，了解到了一些平时没见过的知识点，可以说是收获满满 exp covercover.zip 题目分析 没开pie 这里导致了我们的code段可写，说明可能需要修改code段里的数据，方向大致朝这个方向想 这里跳过if判断使得程序不会跳出，目前为止是一个正常的程序，但是通过gdb调试发现if判断后会有一段异常的汇编代码 这里输入的是b’’*4+b’66’，可以看到程序运行到这里是将0xffffffff地址的最后一个字节的数据改成0x66，因为之前分析了code可写，那么可以考虑将put的plt表里的got地址跳转地址修改成system的got地址,可以看看got表的数据 system的got刚好就在putsgot的下面，所以只需要将最后一个字节0x20改成0x24就可 put的plt表中jmp后的got表的最后一个字节为ff需要加2使得最后一个字节为20，改20为24就可 exp "},{"title":"2021_BUUCTF&DASCTF_pwn","date":"2021-05-30T14:35:03.000Z","url":"/2021/05/30/2021-5-30/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["heap","/categories/heap/"]],"content":"PWN：pwnpwn.zip 运行环境为ubuntu18.04，libc-2.27 题目分析不用想保护全开，经典菜单题 菜单有malloc、free、edit、show功能，有一个offbyone漏洞，可以尝试三明治攻击构造两个指向同一块chunk的指针，还有一种方法就是利用overlapping来攻击 方法一思路 先将大小为0x90的tcachebins填满 然后构造0x91（free）—0x90（used）—0x91（used）三明治布局 利用offbyone修改第三个堆块的presize和pre_inuse位，利用unlink得到一个0x1B0大小的堆块包含中间的0x90 将第一个堆块申请出来，通过第二个堆块（used）就可以泄露地址 再申请一个堆块就得到两个指向同一块chunk的指针即第二个堆块 通过攻击tcachebins来写malloc_hook为one_gadget 申请堆块获取shell 坑点 offbyone漏洞一开始没发现，后续仔细分析了一下发现很简单，一开始没静下心来分析 不清楚题目的libc版本，题目只给了libc.so 注意最后一个堆块要额外申请一个小堆块，防止与top chunk合并 题外话：比赛当天有事导致题目没怎么看，准备赛后复现，然后第一道堆题环境是2.23版本的，不太熟悉就没怎么看了，主要是第二道堆题（现在写的），offbyone漏洞一开始没发现，看大佬的博客发现漏洞后（就是当申请的堆块的size的倒数第四位为一，就差不多行了刚好8满足需求）就感觉可以做出了，自己尝试了一下，确实发现没什么难度，这类题目做过类似的所以挺简单的，文章末尾会附上一些大佬的wp和一些例题 exp 方法二思路 构造三个堆块0x21（used）-0x91（used）-0x21（used） 然后利用offbyone修改第二个堆块的大小，使得第二个堆块的大小刚好覆盖第三个堆块（也就是将第二个堆块） 释放第二块堆块，再申请0x91大小的堆块，这样就可以通过第三个堆块泄露地址 再申请一个0x21堆块就得到两个指向同一块chunk的指针即第三个堆块 写free_hook为system地址，释放带有/bin/sh的块获取shell exp 参考博文：    推荐例题： "},{"title":"2021_360CTF_pwn","date":"2021-05-27T14:15:11.000Z","url":"/2021/05/27/2021-5-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["heap","/categories/heap/"]],"content":"PWN：lonelysolf题目涉及知识点lonelywolf.zip 先讲讲本次题目所涉及的知识点（我一开始的知识盲区）：tcache_perthread_struct结构体，先看看源代码的样子 可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。这里写了一个简单的实验，通过调试来理解tcache_perthread_struct结构体的工作方式。 堆调试实验一程序代码： 调试截图（这里程序运行到了释放最后一个chunk的位置）可以看看bin里的内容 再看看堆块的情况，可以看到它的第一个chunk（tcache_perthread_struct结构体）的位置（0x555555559000） 可以看一下tcache_perthread_struct结构体里的内容 这里可以验证字符数组里存放的就是tcachebins的计数器里的值，然后可以看看指针数组里存放的是不是释放后堆块的地址 可以发现指针数组里存放的就是是释放后堆块的地址，通过这个实验可以了解tcache_perthread_struct结构体的管理结构，这个是这次题目的攻击对象，然后在介绍攻击方式：tcachebins里的double free。 这里看看tcachebins链表的结构： 再来看一下free中是怎么处理添加chunk到tcache的，不同于malloc_libc_free对外的接口不直接处理tcache，而是在_int_free这个模块内部例程中处理有关tcache的操作 可以看到这就是tcache的double free检测机制，判断条件就是tcache_entry的key指针（堆块的bk指针位置）是否等于tcache（通过接下来的实验可以发现就是堆初始化的时候申请的第一个chunk的数据地址），这里写了一个简单的tcache的double free的实验。 堆调试实验二程序代码： 这个是第一次free的情况 可以看到tcache_entry的key指针（堆块的bk指针位置）就是堆初始化的时候申请的第一个chunk的数据地址，接下来我们通过填充字节’A’来破坏它 这个是填充字节之后的情况，可以看到bk指针也就是key指针已经被我们修改了，这样的话我们再次释放就可以绕过检测了，接下来可以再次释放就可以达到double free的目的 目的达到，而且这个还是2.31相对高版本的glibc（注：tcache_perthread_struct结构体在2.31版本有些不一样，可以自己通过上面的第一个实验来比较，这里就略过） 题目分析 漏洞分析： 经典的菜单题目，可以看到它我们每次malloc的大小限制到了fastbins范围内，而且每次malloc都会清空上一个的chunk指针（这里限制了我们填充tcachebins的方法），但是free不会清空，这里就有一个UAF漏洞，然后我们的目的是伪造unsortbins（第一个堆块刚好满足条件，而且可以修改tcachebins的计数器），然后free，泄露地址（原理：当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址） 思路有了，先重新构造函数 通过double free达到任意地址读写，同时泄露堆块的地址（用来计算堆初始化的时候第一个chunk的地址，通过第一个chunk达到攻击的目的） 然后就可以修改free chunk的fd指针使其指向堆初始化的时候第一个chunk的地址，然后就可以申请到堆初始化的时候第一个chunk了 要将当前的chunk释放到unsortedbin里，就要先将tcachebins填满，这里可以通过修改第一个堆块的值将tcachebins伪造成满的（根据第一个实验就很容易理解了） 接下来就好办了 exp： 参考博文：   "}]