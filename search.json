[{"title":"湖湘旅游日记之house of muney","date":"2021-12-12T07:33:27.000Z","url":"/2021/12/12/%E6%B9%96%E6%B9%98%E6%97%85%E6%B8%B8%E6%97%A5%E8%AE%B0%E4%B9%8Bhouse-of-muney/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"湖湘旅游日记之house of muney写在前面之前打线下都没有笔记，这次比赛第一次打awd plus，给我的感觉就是线下ctf，hhhh（得亏没爆0）。 日程有点赶，长沙没怎么玩，每次出去比赛后脚都有一个比赛，刚到了长沙就点了一杯茶颜悦色，味道还是挺不错的。还面基了好多师傅，没吃到长沙的臭豆腐有点小可惜哈哈哈，不过还是挺赚的。 言归正传，还是来看看这次要学的东西。 原理分析先附上大佬的博客： 大佬的博客已经讲的很清楚了，我这里就简单的总结一下。首先程序要有Partial RELRO的，和延迟绑定的道理一样。我们最终是利用sym-&gt;st_value改为我们要执行的目的代码地址比如one_gadgets。 但是原本这一块地址是不能写的，但是当我们申请极大块的chunk时，都会放在特殊的mapped区域。比较特殊的是当我们释放这类chunk时会直接回收至内核。通过这个特性，我们可以释放一些不可写的区域，然后申请再拿回对应区域，并且使得其有可写的权限，这样我们就可以对Elf64_Sym进行修改。 然后有几个检测的地方，要满足的条件如下： 不同环境可能会有一些不一样,我的环境是Ubuntu 18.04(Ubuntu GLIBC 2.27-3ubuntu1.4)，这些值可以通过调试获得。 题目分析菜单题目，有编辑、申请、删除功能，还有一个功能就是修改堆块size。申请的堆块大小最小是0x100000也就是mapped范围，而且只能申请两个chunk。 思路申请两个mapped范围的，然后修改size，使其覆盖.gnu.hash和.dynsym，而且范围确保不会影响到.dynstr。然后将其释放再申请出来（要申请比原来要大的chunk），这是因为M_MMAP_THRESHOLD会随着munmap/free操作发生增长，若分配的大小小于M_MMAP_THRESHOLD，堆操作将回到常规堆空间进行（大佬博客里摘的）。然后通过编辑堆块修改对应的值。通过exit（将被解析成one_gadgets）来拿shell。 exp"},{"title":"Glibc2.32源码分析之exit部分","date":"2021-12-10T14:26:29.000Z","url":"/2021/12/10/Glibc2-32%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bexit%E9%83%A8%E5%88%86/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["pwn","/categories/pwn/"]],"content":"Glibc2.32源码分析之exit部分前言为了深入理解house of banana，决定分析一下源码，水平有限大佬勿喷，写得不是很好，有错误的地方望提出指正，共同进步。 原理分析调试代码 查看exit源码，这里用到了exit_function_list还有exit_function结构体 我们在这里可以看到源码是直接调用__run_exit_handlers，可以在源码里看到对应的参数类型，同时gdb跟进去调试的时候也可以看到对应参数。 对应源码，我们可以看到，因为run_dtors为1，所以函数会先调用__call_tls_dtors函数。 __call_tls_dtors遍历tls_dtor_list调用函数查看__call_tls_dtors源码，同时gdb跟进__call_tls_dtors。里面有一个dtor_list结构体定义的tls_dtor_list指针，__call_tls_dtors这个函数的作用就是遍历tls_dtor_list结构体链表，每次遍历都会用到tls_dtor_list里的func，将tls_dtor_list里的obj作为第一个参数，这里其实也可以进行利用，只要将tls_dtor_list覆盖成我们的堆地址，便可以控制调用函数和其参数。 循环处理使用“atexit”和“on_exit”注册的函数。在大概读了整个流程后，发现整个循环（两层循环）都只执行了一次；因为cur-&gt;next==null且cur-&gt;idx为1；在第一次while (cur-&gt;idx &gt; 0)里有--cur-&gt;idx的操作，所以循环一次；然后在循环退出的时候；*listp = cur-&gt;next;.....cur = *listp;使得在第一次while (true)的循环后，第二次循环开始的时候if (cur == NULL)&#123;......break&#125;；退出循环。 可以gdb动调看一下 整个循环源代码如下 在循环里定义了一个exit_function结构体f，为exit_function结构体数组cur-&gt;fns里的第一个exit_function结构体，而且可以通过gdb调试看到此时的f-&gt;flavor为4，ef_cxa（在stdlib/exit.h里定义了）为4。根据注释里讲的，为了避免dlclose/exit争用两次调用cxafct，所以将exit_function结构体里的f-&gt;flavor置为ef_free，即置为0。然后cxafct就赋值为0xb685d3b1e02215a8（每次程序运行的时候都是不一样的） 然后紧接着就是通过PTR_DEMANGLE处理cxafct，成功解析_di_fini函数 调用前 调用后 可以看到这里的cxafct转换成了_dl_fini地址，然后就是我们house of banana所用到的函数_dl_fini。 进入_dl_fini函数然后就是进入这个_dl_fini函数，看一下源代码 可以看一下GL的定义和_rtld_global、link_map大概结构体， 此时nloaded赋值为_rtld_global-&gt;_dl_ns[0]._ns_nloaded即4（链表的个数），根据调试代码知道从else命令行开始执行。其实注释里有说明接下来的操作，分配数组来保存指针。 我们可以通过link_map结构体指针l_next指针来看一下有哪些link_map结构体是这链表的。 直到link_map结构体指针l_next为null，一共有4个link_map结构体，之后就是遍历链表（源码如下），判断l（rtld_global结构体里的link_map结构体指针即_rtld_global._dl_ns._ns_loaded）的link_map结构体地址是否与结构体l里的l-&gt;l_real相等，相等的话继续遍历，将链表添加到maps里，同时i加一（初始为0）。因为后面有一次断言，这样使得我们每次遍历的时候都要满足l == l-&gt;l_real，否则计数器i没有办法与nloaded（上面说到的链表长度）相等。还有一种情况就是ns != LM_ID_BASE进入下一个断言，这里就不细说，道理是一样的。 可以看一下maps数组里的指针 然后就是nmaps（nmap=4）次循环，之后判断link_map结构体l里的l-&gt;l_init_called是否为1，调试看一下发现为1。 接下来判断link_map结构体l里的l-&gt;l_info[DT_FINI_ARRAY] != NULL。 我们可以调试看看这里的值，不为null，执行if条件判断里的指令。 然后就是可以计算array的值，为15800+93824992231424=0x555555557DB8其实就是fini_array 后面的话_dl_fini函数进行剩下的三次循环，然后我们就回到__run_exit_handlers，因为cur-&gt;idx==0且cur-&gt;next==0。 然后跳出循环，之后就调用_exit (status);，程序结束。 编写测试代码测试机的环境是Ubuntu 21.10，地址随机化关闭 第一部分__call_tls_dtors利用思路可以先看看源代码，还有对应结构体。 思路确实和简单，伪造dtor_list结构体，将结构体地址写入tls_dtor_list，使得其不为空，然后调用func (cur-&gt;obj);。但是还有一步，就是PTR_DEMANGLE (func);这个操作，这里要讲一下在linux里有一种线程局部存储机制，简称TLS它主要存储着一个线程的一些全局变量，包括我们熟知的canary也存储在里面，我们可以看看对应结构。 我们可以gdb调试看看对应的汇编代码 可以看到PTR_DEMANGLE (func);这操作主要是先进行循环右移0x11位，再与fs:0x30（tcbhead_t-&gt;pointer_guard）进行异或，最终得到的数据就是我们的函数指针，所以我们只需进行逆操作就可以控制函数地址。 最终代码 第二部分_dl_fini利用思路我们的目的是控制_dl_fini里的array指针数组并调用它，首先要控制rtld_global结构体里的link_map结构体指针即_dl_fini函数里的link_map结构体l。 首先是伪造rtld_global结构体里的link_map结构体指针即rtld_global-&gt;_ns_loaded，为了不破坏link_map链表的完整性，因为后面有一次断言判断：检测链表的长度，上面也讲了 所以我们结构体里的link_map指针l_next要保持不变而且link_map结构体l里面的l_real即l-&gt;l_real要指向它本身的地址。 然后就是构造并调用我们伪造的函数 然后要使link_map结构体l里面的l_init_called即l-&gt;l_init_called为1。 接下来要使得l-&gt;l_info[DT_FINI_ARRAY] != NULL即l-&gt;l_info[26] != NULL，我们可以看看array是怎么算的。 可以看看l-&gt;l_info[DT_FINI_ARRAY]里的指针对应的结构体 所以我们可以将l-&gt;l_addr改为堆块的地址（堆块地址指向我们的后门函数地址），然后将l-&gt;l_info[DT_FINI_ARRAY]里的指针指向对应结构体Elf64_Dyn，该结构体我们可以伪造，可以改结构体里的d_ptr为固定的值（比如0x20或是0）。我们这里伪造为0；然后就是选定一个可读的地址 就好了。 然后就是满足循环条件，这里我们可以调汇编来看 所以我们可以伪造i为1 最后就是将l-&gt;l_addr改为堆块的地址（堆块地址指向我们的后门函数地址） 最终代码 实例利用题目分析魔改的2021湖湘杯2.34的pwn（将原来的_exit改成exit），chunk申请范围是0x40f到0x500，漏洞是uaf 这里地址随机化是开了的 方法一攻击原理通过两次largebin attack将已知地址写入结构体指针tls_dtor_list和fs:0x30（tcbhead_t-&gt;pointer_guard）里，然后风水布置堆块，伪造dtor_list结构体，接下来就是利用__call_tls_dtors函数来调用我们的指针，这里找到了不错的gadget 可以通过rdi控制rdx，再调用setcontext+61进行栈迁移，orw读出flag。 exp 方法二攻击原理利用第二部分的思路来进行攻击：控制_dl_fini里的array指针数组并调用它，伪造link_map结构体，这里有一个巧妙的地方就是上一个((fini_t) array[i]) ();执行完之后会将上一个调用的函数地址保存在rdx寄存器里，然后如果我们可以伪造array[i]为setcontext+61，在第二次调用((fini_t) array[i]) ();（如果有的话）我们就可以通过rdx控制其他寄存器。 exp 资料参考：  文章首发于安全客"},{"title":"2021赣网杯pwn部分wp","date":"2021-12-07T13:46:32.000Z","url":"/2021/12/07/%E8%B5%A3%E7%BD%91%E6%9D%AFpwn%E9%83%A8%E5%88%86wp/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"ezpasswd题目附件 题目分析 主要还是前面密码的绕过。 这里通过将v4数组填满泄露出计数器i，使得我们可以不断尝试爆破密码 然后就是构造rop链进行攻击 exp pwn题目附件 题目分析 add配合edit可以任意写，但是比赛的时候卡在了leak地址上，赛后看了wp恍然大悟，这道题目感觉就是单纯考技巧，打法和西湖有点类似，改alarm的got表为syscall，配合byebye函数泄露地址，巧就巧在，alarm的第一个参数即rdi为1，其他参数刚好是read后的堆地址和size，然后read可以控制rax寄存器，然后可以打印堆块里面的内容，泄露地址可能这个方法会比较好。 leak地址之后就是改delete的got表为setcontext+53，然后就是srop拿flag exp"},{"title":"通过一道题学习house of pig","date":"2021-10-07T14:49:42.000Z","url":"/2021/10/07/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6%E4%B9%A0house-of-pig/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"通过一道题学习house of pig题目附件 题目分析最近看到一个比较有意思的题目，是pwn_RenCvn师傅给的，基本的菜单功能，但是是通过calloc来申请堆块的大小限制在small bin范围内，漏洞也挺明了的，就是uaf，题目使用的是 libc2.31 参考大佬博客：，基本上都是这几篇博客的整合。 因为没有large bin范围的chunk申请，所以large bin attack没办法用，我唯一想到可以用的就是tcache_stashing_unlink_attack，可以任意空间写一个大地址。 思路执行 Tcache Stashing Unlink Attack tcache bin和SmallBin中的情况为： 那么我们接下来若申请一个大小为0xa0的Chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1。在取出Chunk 1后，因为0xa0的Tcache Bin还有2个空位，程序会首先遍历发现Chunk2满足大小条件并将其作为参数调用tcache_put。 若此时，我们篡改了Chunk 2的bk指针为Fake_Chunk的地址(_IO_list_all-0x10)，那么程序接下来会将Small bin的bk指针置为_IO_list_all-0x10，并且在_IO_list_all-0x10 -&gt; fd的位置写入bin的地址，也就是main_arena的地址。 通过tcache_stashing_unlink_attack写_IO_list_all为一个main_arena上的一个地址 然后在main_arena上对应FILE 结构的_chain字段劫持为堆地址（通过释放对应位置的chunk） 后面就是伪造 FILE 结构，最重要的一点就是将IO_file_jumps 修改为 _IO_str_jumps,那么当原本应该调用 IO_file_overflow 的时候，就会转而调用如下的 IO_str_overflow。而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc、memcpy、free 函数（如下图） 然后布置堆块，在0xa0的bin中留下两个堆块 其中一个是malloc_hook,然后我们利用io_file的非预期堆块申请申请到malloc_hook同时用非预期填充将malloc_hook填充为setcontext，然后通过布置寄存器，来拿shell。 然后我们看一下我们的fake IO_FILE_plus Fake IO_FILE_plus1(malloc(0x90)) 可以看到第二行的两个地址差22，而通过我们的size计算可以得出size = (0x90-100)/2 = 22,是根据伪代码里的这个得到的： 执行完之后： Fake IO_FILE_plus2(malloc(0x90) &amp;&amp; hijack malloc_hook = setcontext) 执行完之后： 然后再malloc就劫持到setcontext+61这里了，接下来执行第三个IO_FILE_plus就会触发srop。 Fake IO_FILE_plus3:(srop) 然后这里有一个小细节。就是在IO_str_overflow里的汇编里 可以看到在调用malloc之前的0x7ffff7e6db65位置rdx被赋值为 [rdi+0x28],而此时的rdi恰好指向我们伪造的IO_FILE_plus的头部，而在glibc2.29的版本上setcontext的利用从以前的rdi变为了rdx，因此我们可以通过这个位置来进行新版下的setcontext,进而实现srop,具体做法是利用非预期地址填充将malloc_hook填充为setcontext，这样在我们进入io_str_overflow时首先会将rdx赋值为我们可以控制的地址，然后在后面malloc的时候会触发setcontext，而此时rdx已经可控，因此就可以成功实现srop。 可以看看调试过程： 成功srop exp"},{"title":"江西省第四届省赛(pwn部分)","date":"2021-09-27T15:49:56.000Z","url":"/2021/09/27/%E6%B1%9F%E8%A5%BF%E7%9C%81%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%9C%81%E8%B5%9B-pwn%E9%83%A8%E5%88%86/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"江西省第四届省赛（pwn部分）写在前面今天打了一场省赛，个人感觉不是很好，pwn题比赛开始不给附件，就给了一个ip和端口，盲打了半个小时，才给附件，还不给通知，偷偷摸摸放了个附件，还是队友提醒我，不然盲打一天。多多少少不太行，这次比赛给我的印象不太好，不过题目质量还行，可惜状态不太好，第一个pwn比赛结束才出，希望下次能办好一点😒。 Slag_man_notes题目分析题目附件 基本功能都有，存在漏洞uaf，主要是add申请堆块的时候会将堆块限制成固定大小，但是还有一个add可以申请0x60的堆块。 思路申请一个0x190的堆块，然后释放，leak基地址。 通过申请0x60的堆块，将释放的堆块指针指向的堆块切割成0x71大小的堆块 然后就可以用该堆块配合uaf写malloc hook为one_gadget,然后触发one_gadget exp bookstore题目分析 有菜单的基本功能，但是申请堆块限制了次数，释放堆块也申请了次数，只够我们leak地址，没有写的机会，卡的死死的，当时肝了这题好一会，可惜没干出来，状态不是很好。 思路这个题目应该有两种解题方法，一个是伪造io file结构体来打，还有一种就是我用的方法（house of banana），一开始本来是打算用io file结构体来打的，远程的环境有点给我整破防了，没调明白。后来没办法尝试house of banana，结果就通了，后来总结了下，这个好像是万精油，只要能申请large bin范围大小的堆块就可以尝试用这种方法，配合uaf效果更好 附上poc，可以自己调调看 poc 这个是我自己调好的exp，可以参考大佬博客： exp"},{"title":"2021_天翼杯_pwn","date":"2021-09-23T15:44:35.000Z","url":"/2021/09/23/2021-%E5%A4%A9%E7%BF%BC%E6%9D%AF-pwn/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"写在前面这个比赛难度还是比较大的，才出了一道pwn题，总共就看了两道题目，写点笔记记录一下 chaos题目附件 题目分析及漏洞利用 前面是有一点代码审计的感觉，不过还是比较简单的，花点时间就好了，后面就是常规的菜单题目。chunk其实就是简单的单链表结构，释放的时候就是简单的脱链。 在申请堆块的时候存在溢出，可以修改到size部分，然后配合编辑就可以修改chunk_addr，再编辑就达到任意地址写。 同理也可以达到任意地址读的操作，也是修改chunk_addr指针部分 exp"},{"title":"ret2dlresolve学习笔记","date":"2021-09-22T15:51:04.000Z","url":"/2021/09/22/ret2dlresolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["stack","/tags/stack/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["pwn","/categories/pwn/"]],"content":"写在前面本篇文章只是一些学习记录、打卡，很大部分是摘自其他大佬博客，还有一些自己的东西，文末会贴上链接，练习建议自己独立完成。 前置知识在Linux中，程序使用_dl_runtime_resolve(link_map,reloc_offset)来对动态链接的函数进行重定位。而ret2dlresolve攻击的核心就是控制相应的参数及其对应地址的内容，从而控制解析的函数。 延迟绑定需要了解3个结构以及他们之间的关系 程序在执行前，如果对整个动态链接库函数进行符号解析的话，是非常浪费资源的，因为一个程序不可能调用动态链接库中所有的函数。我们最好能做到只对用到的函数进行函数解析，这样可以大大提高文件链接的效率，加快程序的启动速度。 这时候，就出现了延迟绑定技术，我们通过plt表（过程链接表），在第一次调用函数的时候，来确定函数的地址，把函数的实际地址存储在got表相对的偏移处。 试想一下，在这个过程中，当我们第一次调用函数，要向got表写入函数真实地址的时候，我们是不是需要一个管理的工具？这个管理的工具就是_dl_runtime_resolve()函数。函数需要两个参数，一个是要被绑定的函数所在的模块，一个是要被绑定函数的符号名。 函数原型：_dl_runtime_resolve(link_map,reloc_arg) 注：got表实际上是分为.got表和got.plt表，got.plt表（全局函数偏移表）中存放的是动态链接库函数，.got表（全局变量偏移表）里面的偏移主要是全局变量。我们在这里讨论的是got.plt表。 .got.plt表的前三项的含义分别如下: 1.got[0],第一项保存的是”.dynamic”段的地址，这个段描述了本模块动态链接相关的信息； 2.got[1],第二项保存的是本模块的ID； 3.got[2],第三项保存的是_dl_runtime_resolve()函数的地址。 且我们需要知道.got.plt前三项的特殊用途 address of .dynamic link_map dl_runtime_resolve _dll_runtime_resolve函数的2个参数 _dll_runtime_resolve函数的运行过程 练习小练习1参考博客： ret2dlresolve超详细教程(x86&amp;x64)_77Pray的博客-CSDN博客 先编译以下代码，逐步利用_dl_fixup函数最后get shell 首先是先栈迁移到bss段，再手动调用plt[0]，解析write函数，把命令打印出来，我们只需提前push reloc_arg（push 20h）即可完成利用 对应的是这一句 has exp 成功打印字符串 小练习2这一步我们控制好reloc_arg的大小，使reloc的位置落在可控地址(bss段)内，在bss段手动伪造出reloc，即伪造.rel.plt中关于write的内容，从而可以控制它的r_info 对应这一句 .rel.plt节是用于函数重定位，**.rel.dyn**是用于变量重定位 下面是rel的结构体定义 exp 小练习3这一步我们控制好reloc中的r_info，使sym落在可控地址内，从而伪造sym，从而可以控制它的st_name（偏移） 对应这两句 .dynsym节包含了动态链接符号表。ELF32_Sym[num]中的num对应着**ELF_R_SYM(Elf32_Rel-&gt;r_info)**。根据定义， ym的结构体如下（大小为0x10） has 注意16字节对齐 exp 小练习4相信到了这一步，对于接下来要做什么已经很清楚了，既然在上一步我们能控制st_name，那接下来自然是伪造st_name，从而可以控制字符串表 对应这一句 exp 大佬博客ret2dlresolve利用方法_九层台-CSDN博客 栈溢出之ret2dlresolve学习 - FreeBuf网络安全行业门户 ret2dlresolve超详细教程(x86&amp;x64)_77Pray的博客-CSDN博客 [新手向]ret2dl-resolve详解 PWN——ret2dl_resolve - Riv4ille - 博客园"},{"title":"暑假刷题笔记","date":"2021-09-21T09:43:20.000Z","url":"/2021/09/21/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"水一篇博客，这个是题库 题目附件提取码: r2en [V&amp;N2020 公开赛]simpleHeap远程是libc2.23版本的，但是我想试试用libc2.27版本来看看可不可以打通（有点难度），亲测能行 题目分析有一个offbyone漏洞但是限制了我们的chunk在0x6f范围内，想要通过unsortedbins泄露地址需要将tcachebins填充，但是限制了chunk大小，所以不能简单的释放就能填充，可以考虑overlapping。 思路 构造三个堆块，第一个堆块用来修改第二个堆块的size，使得第二个堆块覆盖第三个堆块的头，用来控制第三个堆块 释放第三个堆块，泄露chunk_head地址，通过tcache_perthread来泄露基地址，写free_hook为system，通过释放带有/bin/sh的堆块来getshell 坑点 原题的攻击方法是基于libc2.23的，本地的版本是libc2.27的，可以说攻击方式完全不同，不过通过这个题目更了解libc2.27的堆管理情况 一开始想了很多方法，都没成功，版本不同对题目的难度加大，不够学到了很多，对2.27版本有进一步的认识 0ctf_2016_warmup题目分析 栈溢出,突破点就在于alarm函数了。alarm函数有一个特性，如果多次调用alarm，那么alarm就会返回前一个alarm开始到现在，还剩下多长时间。比如，第一次alarm(10)，然后过来2s，我们又调用alarm(1234)，那么第二次的alarm返回值eax为10s-2s=8s。 exp 0CTF_2017_babyheap题目分析一个简单的菜单题，有增删改查功能，编辑功能存在堆溢出 思路 通过堆溢出来实现堆块重叠 通过堆溢出改写堆块大小，通过unsortedbins来泄露libc地址 利用fastbin attack改malloc hook为realloc hook（在malloc hook-8的位置），改realloc为one_gadget，通过不断尝试realloc的正确偏移为10 exp ciscn_2019_sw_1题目分析 格式化字符串漏洞，但是只有一次调用 思路 这里利用到了fini_array劫持技术，可以使程序再次运行一次 然后改printf‘s got为system’s plt表 输入/bin/sh,拿到shell exp hitcontraining_playfmt题目分析 一个无限循环的格式化字符串漏洞 思路 利用ebp的双重指针来修改栈上的数据 改返回地址为system，参数布置在栈上 exp get_started_3dsctf_2016题目分析简单栈溢出，打卡题目 exp not_the_same_3dsctf_2016题目分析简单的栈溢出，布置好参数传递就行 exp babyfengshui_33c3_2016题目分析 思路 风水布置堆块，达到任意地址读写 改free的got表为system 释放包含‘bin/sh\\0’的堆块get shell exp 2021_强网杯_NO_output题目分析 满足两个条件就可以进行栈溢出了，一个是检测字符串是否相等，可以用\\x00截断绕过，还要满足的条件是signal 浮点异常的信号才能触发漏洞，利用ret2dlresolve就行，可以参考我的学习笔记 exp C语言编程技巧-signal(信号)  rec_33c3_2016rec_33c3_2016(堆栈不平衡) 题目分析 Polish里有栈不平衡会拔高栈帧 思路 通过栈上残留地址，leak基地址 利用栈不平衡，不断拔高栈帧，让栈降低到合适的位置，然后就可以通过push向栈中写数据 v2函数指针调用我们的函数 exp sctf_2019_easy_heap(改)题目分析经典的offbyone漏洞，程序稍微改了点，希望能用2.31版本来测试，之前使用2.27版本打的这倒道题目，因为2.31版本对于unlink多了两个检测，一个是检测释放chunk的pre_size是否等于要合并chunk的size大小，还有一个是检测要合并的chunk是否是自连，目前我找到的方法有自己伪造堆块头，利用offbynull漏洞来unlink，还有个是利用large bin的残留信息。 改动如下，因为没有输出所以有一定的难度 思路 通过泄露的堆块地址来伪造堆块头 利用offbynull来使堆块与我们的fuke堆块合并 这样就可以照成堆块复用，导致任意地址读写，先将shellcode注入到rxw段上，可是题目没有输出堆块的功能 可以使用三个堆块复用，利用double free，一个chunk在tcache bins，一个在unsorted bins里（这个要构造比较特殊，需要用到切割unsorted bin来实现），因为main_arena+96的位置和malloc hook的位置很近，只需修改一个字节就好，改malloc hook为shellcode地址 大概成功以后是这个样子 这样申请两个0x100的堆块就可以改到malloc hook里的指针 exp 360chunqiu2017——smallest题目分析 2017 429 ichunqiu ctf smallest(pwn300) writeup_jmp esp-CSDN博客 思路 通过srop来控制寄存器 注意要保持read持续输入 exp 2018_breakfast题目分析 一个uaf，一个任意地址读，堆打卡题，简单直接撸代码 思路 leak free的地址，算出libc基地址 改free hook为system 释放包含‘/bin/sh\\x00’的堆块get shell exp music题目分析格式化字符串漏洞和栈溢出 exp ichunqiuyiqing_borrowstack题目分析 思路 利用rop链控制寄存器来进行攻击，首先需要泄露地址 然后就是常规rop攻击，这里我用到了ret2csu 坑点可以说之前有一个地方困扰了我很久，就是经常栈迁移的时候程序经常dang了，这次我理解了，因为bss段上面一块区域是一个只有只读权限的内存空间，当我们进行系统调用的时候往往需要压栈的操作，这种操作往往会使的栈不断地拔高，一旦栈帧指向了只有只读权限的内存空间的时候就会报错，因为对栈帧的操作往往需要有写的权限，这也是我经常忽视的地方，所以栈迁移的时候尽量迁移到bss段后面 exp Dream题目分析存在格式化字符串漏洞，可以用来leak地址，编辑堆块的size可控，可以造成堆溢出，还有一个uaf漏洞，可以达到任意地址读写 思路 利用格式化字符串漏洞leak地址 利用fastbin attack改malloc hook为realloc hook（在malloc hook-8的位置），改realloc为one_gadget exp ichunqiuyiqing_excited题目分析堆块里存在指针，而且有uaf漏洞，flag文件读取到内存里了，可以通过特殊布局利用uaf来将指针指向flag的位置，再读取打印 exp ichunqiuyiqing_interested题目分析 存在格式化字符串漏洞leak地址，UAF漏洞，堆打卡 exp SCP_Foundation题目分析存在uaf漏洞，堆块存在指针，有show、add、free功能，flag已经读取到内存中了，直接把堆块里的指针改成对应内存快的指针就可以读取flag了 exp axb_2019_heap题目分析存在格式化字符串漏洞leak地址，没有show功能，只能申请0x80以上的堆块。有一个offbynull漏洞。 涉及知识点unlink 本次攻击是将chunk0指向数据的指针当作指向伪造chunk头的指针，FD-&gt;bk、BK-&gt;fd就是我们伪造的指针，他们都同时指向bss段上chunk0的指针，可以将bss段上的指针改成BK-&gt;fd。这样就可以控制堆块指针达到任意地址读写 exp"},{"title":"2021_长城杯_pwn","date":"2021-09-21T09:07:43.000Z","url":"/2021/09/21/2021-9-20/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"中秋放假打了下长城杯，干了两pwn，战绩不错，后面复现了企业组的pwn3，写个博客记录下。 K1ng_in_h3Ap_I题目附件 题目分析 菜单题目，没有show功能，漏洞还是挺多的,uaf和offbyone随便一个都够打，有leak3字节的地址就省去爆破倒数第四位的功夫了，打stdout来泄露地址，改malloc hook为one_gadget来拿shell。可以参考这位师傅的博客： 思路通过风水布置堆块使得bin里的结构达到这个效果 此时可以利用题目给的偏移计算stdout地址，部分修改fd指针，将堆块申请到附近。 然后将缓冲区base地址指针改小就可以泄露指针范围的地址 改完以后是这个样子 然后就会输出该指针范围内的东西，最后面调用的就是_IO_new_do_write 得到地址就可以打malloc，然后用realloc调偏移 IO FILE系列的相关知识可以看看这位大佬的博客： exp K1ng_in_h3Ap_II题目附件 题目分析 菜单题功能很全但是malloc的chunk限制了大小，free后指针没有清空，存在uaf漏洞。开了沙盒保护。 思路确实思路挺简单的，通过攻击 tcache_perthread_struct可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。 通过uaf将该chunk申请出来 然后将结构体里的counts数组都填充成\\x07,也就是tcachebins存放chunk的最大范围，这样我们释放tcache_perthread_struct然，就可以得到地址了。 然后控制这个结构体就可以达到任意地址写。 然后劫持free hook为setcontext+53。 在释放的堆块里布置对应的寄存器。这样就可以通过rdi（也就是我们释放的堆块）来控制寄存器。然后就orw拿到flag exp ~XLVXR5H9H6%5BQ%7DNON.png “”) hellopwn（企业组）题目附件 题目分析 题目情况大概就是这样了，没有打印功能，限制了编辑和释放堆块的次数，chunk的大小范围控制在了large bin范围内。在释放堆块的时候，指针未清空，存在uaf漏洞。 思路先通过magic打stdout泄露地址，和之前的方法一样，把缓冲区base地址的指针改小就可以了，然后就是通过large bin attack来完成后续的操作，下面讲一下。参考师傅的博客： 在glibc2.31版本里常规的large bin attack被封杀了，但是large bin attack还有另一个分支可以利用 可以看到在glibc2.32版本里加了一个链表完整性的检测，但是他封杀的只是其中一个分支，还有一个分支可以利用，可以达到任意地址写一个我们可控的堆块地址。 通过控制large bin里的bk_nextsize来达到任意地址读写，再申请比unsorted bin还大的chunk来触发漏洞（unsorted bin里chunk的size要小于large bin里的size） 大概堆块布局的这样的 通过uaf控制large bin里的chunk，改写large bin里的chunk的bk_nextsize,来达到任意地址写一个堆块地址。 再申请一个大堆块触发漏洞 我们来看一下tcache部分的源码 然后我们的目的就是将覆写mp_.tcache_bins的值为一个很大的地址，使得large bin大小范围的chunk被释放也会放到tcache bin里，后面就简单了，因为申请tcache bin的chunk不会检测size是否合法，所以我们就可以利用uaf达到任意地址写的效果。 exp"},{"title":"2021_redhet","date":"2021-09-21T08:55:49.000Z","url":"/2021/09/21/2021-redhet/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"]],"categories":[["pwn","/categories/pwn/"]],"content":"题目附件 manager题目分析一个菜单题，有Insert、Delete、Show功能，通过二叉树管理堆块 Insert这里写了一点insert的流程（根节点主要画了右子叶，左子叶原理都是一样的） 总结来说，小的往左边放，大的往右边放，找到相等的就不放 Delete大概可以分为四种情况 清空的堆块没有左子叶，有右子叶 清空的堆块没有右子叶，有左子叶 清空的堆块没有右子叶，没有左子叶 清空的堆块有右子叶，有左子叶，这个情况有点麻烦，但同时漏洞也出现在这里 漏洞出现在第四种情况 当右子叶的子叶存在左子叶时，就会释放该节点中我们自己申请的堆块，而最后面又会释放堆块（包括我们在里面申请的堆块），所以这种情况下就会出现double free的情况，布局如下： 这里有一些当时部分代码的分析情况可以参考（随便看看就好） show通过中(根)序遍历来显示堆块信息 解题思路 通过特殊布局达到double free效果 通过double free来利用tcache bins来实现任意地址读写 改free_hook为system，通过释放包含‘/bin/sh’的堆块来getshell 坑点 本题为旧版本的glibc-2.27,新版本的包含tcache bins的double free检测机制(可以参考之前写的360的lonelywolf)，一开始在我的Ubuntu上折腾了好久，后面才考虑到可能是glibc版本原因，用patchelf来修改文件的glibc，文末会有相应的教程链接 我觉得最困难的不是漏洞利用，而是代码审计，需要有一定的耐心一步步地分析完 exp ![](2021-redhet/Untitled 7.png “”) patchelf相应教程： parser题目分析 正常地接受字节，无溢出进入循环 主要是这个函数，会对数据进行筛选，过滤 发现漏洞，但需要一定的条件。下面是我对这个程序的分析过程 解题思路 通过格式化字符串泄露地址 改malloc_hook为one_gadget 利用%100000c触发malloc/free，劫持程序控制流 exp "},{"title":"2021祥云杯_pwn","date":"2021-08-27T04:02:39.000Z","url":"/2021/08/27/2021-8-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PassWordBox_FreeVersionPassWordBox_FreeVersion.zip 题目分析 2.27版本的offbynull，有一字长的加密，一开始没想到直接填充/X00就可以leak加密的密钥，无脑爆破，写了个小程序，把密钥爆出来了。贴个源码。 然后就是常规操作，unlink后，达到任意地址读写，改malloc hook为one gadget，申请堆块触发one gadget。可以参考我之前写的 2021_BUUCTF&amp;DASCTF_pwn exp JigSaw’sCageJigSaw’sCage.zip 题目分析 存在溢出，改v2的值，触发mprotect，使得heap区域可执行。 因为有text功能，可以执行堆块里的指令，然后就是写汇编布置参数调用execve(“/bin/sh”)来拿shell exp PassWordBox_ProVersion（赛后复现）PassWordBox_ProVersion.zip 题目分析存在uaf，但是size范围限制在了large bin大小，2.31版本常规large bin attack方法是被修复的，但是还是存在可以利用的漏洞 house of banana - 安全客，安全资讯平台 官方给的思路应该是house of banana，向_rtld_global 里伪造结构体，手法和house of banana一样，主要是一些参数的布置不太了解，当时没复现出，赛后硬调出来了。附上poc，可以调一下。 大佬博客： poc exp 网上还有一种方法，是修改mp_.tcache_bin，使得大于0x408大小的堆块也能在tcache中，这种方法使得我们的攻击更为简单。 从祥云杯PassWordBox_ProVersion看GLIBC2.31 LargeBin Attack_黑客技术 只需要将这里改大就可以使得大于0x408大小的堆块也能在tcache中（利用large bin attack）。主要是这一个，可以看一下tcache部分的代码。 后续就是attack tcache bin，就挺简单了，改free hook 为system exp note(赛后复现)note.zip 题目分析 存在scanf格式化漏洞，有申请堆块的功能，同时会leak堆块地址信息,还有show的功能，没有free 解题思路 通过格式化字符输入修改top chunk的大小（注意地址需要页对其），申请比top chunk大小还大的chunk来将top chunk放入到unsorted bin里来leak地址 然后伪造file结构体（包括vtable结构），将_IO_2_1_stderr_的_chain改成我们伪造的file结构体，在程序结束的时候会调用_IO_flush_all_lockp函数，这个函数最初的目的是为了保留数据不丢失，如果缓冲区还残留数据，就会调用_IO_OVERFLOW来刷新缓冲区，这样的话，我们伪造的file结构体中缓冲区的长度fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base就必须大于0，还有一个检测就是mode要小于等于0 exp 还有一种方式leak地址通过改输出stdout的_IO_write_base使得缓冲区存在数据。 最终执行_IO_do_write来调用系统调用write输出输出缓冲区 IO FILE之fwrite详解："},{"title":"2021_7_BUUCTF&&DASCTF","date":"2021-08-02T09:21:47.000Z","url":"/2021/08/02/2021-7-31/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"],["密码pwn","/tags/%E5%AF%86%E7%A0%81pwn/"]],"categories":[["pwn","/categories/pwn/"]],"content":"BUUCTF&amp;&amp;DASCTFBUUCTF&amp;DASCTF_pwn.zip 进行了长达两天的ctf比赛，第一天从上午10点在电脑面前坐到了晚上十一二点，出了两pwn和一个misc，第二天比较人性化就放了一个pwn题目，一个密码pwn，比较恶心，那个密码还不太会，不过给了密码后面乱杀。总之累死👴了，不过还是挺值的。虽然没有拿到前三血，但ak了，发挥超常，还出了一个misc，一共出了4题，战绩不错。第一次有一种意犹未尽的感觉，题目也挺不错的，下面就分享下解题思路。 pwnEasyheap题目分析一个沙盒堆题，常规的菜单题，保护全开，禁用了execve，得用orw来获取flag 漏洞分析：strup函数比较特殊，这使得我们之前输入的size与实际申请的size有点不一样，这同时也是我们利用的地方。输入size的大小远超于实际输入的字符串，使得我们edit堆块的时候，写入的范围变大，造成溢出。 思路 通过编辑溢出，造成堆块重叠，达到任意地址读写 leak libc基地址，将我们的orw的shellcode注入到rwx段上 然后改malloc hook为shellcode所在地址即rwx段，申请堆块触发shellcode exp realNoOutput题目分析一个典型的菜单堆题 看起来这个程序很完美，一些像offbynull、uaf、溢出漏洞都规避了，似乎没啥子问题，我一开始也想了很多种方法，尝试了一下午，不断地碰壁，本来是打算放弃的，但是当我偶然间查看堆块指针数组的时候发现了一个很奇怪的事 可以看到这里的堆块1指针变为了size（原本是堆块指针的），可以说这里是这个题目的转折点，也是我一直忽略的地方————size数组和堆块指针数组越界了 可以看到数组大小都是8字长的，但是我们的申请的范围是0-9，需要10字长，这会造成我们的指针数组里的数据会被改成size，这个会有什么用呢，因为每次修改、展示、删除堆块的时候都会有两个判断，通过这两个判断会将局部变量buf（栈上的数据）修改成堆块指针，发现就算是清空堆块的时候都不会将栈上的堆块指针清空，所以这里用到了栈的知识。我们每次调用函数结束的时候都会释放函数栈帧，所谓的释放不是清空，而是单纯的不使用这一块栈帧直到下一次调用函数的时候，栈帧里的数据都会一直保持不变。然后要使得局部变量buf上的指针不变则需要回避这个判断 这个就要用到我们的数组越界了，只需要释放chunk，再将释放后的指针位置越界改成size（chunk必须在第0、1的位置），就可以保证该位置不为空，而且不会修改到局部变量buf上的指针，达到UAF的效果，这道题是非预期，后面那道题方法有点类似，也用到栈上的残留的数据 思路 通过上面所讲的栈帧残留可以达到UAF的效果 通过UAF造成堆块重叠，达到任意地址读写 改free hook 为system地址，释放包含’/bin/sh’的堆块，get shell exp canary题目分析 输入用户名和密码，就是常规的栈题，用到的方法和pwn2的类似，利用上一个栈帧残留的信息来leak地址，因为字符串是以\\x00作为截断符的，所以覆盖了就可以leak地址了 思路 通过overflow将栈帧的数据结构进行改写 利用改写后残留的数据信息，可以leak栈上的地址 返回地址改后门函数地址就行 exp miscred_vs_blue 思路nc题，挺适合pwn👴的，直接撸代码，一把梭 exp "},{"title":"2021_蓝帽杯半决赛pwn","date":"2021-06-06T12:54:33.000Z","url":"/2021/06/06/2021-6-6/","tags":[["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"],["stack","/tags/stack/"]],"categories":[["pwn","/categories/pwn/"]],"content":"hangmanhangman.zip 题目分析 题目逻辑大概是先输入一段字符串，生成一段等大小的‘*’（用局部变量v12存放），然后会让你输入一个字符，判断字符是否存在字符串中，如果是则统计该字符个数（当所有字符个数等于原字符串长度时，会有一个格式化字符串漏洞）同时局部变量v12的相应位置（字符串中的相同位置）会变成该字符，程序会进行四次game，也就是说我们有四次利用的机会 思路 先利用格式化字符串泄露libc基地址 然后改malloc为one_gadget 利用%100000c触发malloc/free，劫持程序控制流 坑点 和堆的知识结合利用，通过printf调用malloc 程序稍微有点长，变量会有一点多，需要慢慢分析 题外话，第一次打线下赛，感觉还是很不错的，收获了许多涨了许多知识，了解到了一些平时没见过的知识点，可以说是收获满满 exp covercover.zip 题目分析 没开pie 这里导致了我们的code段可写，说明可能需要修改code段里的数据，方向大致朝这个方向想 这里跳过if判断使得程序不会跳出，目前为止是一个正常的程序，但是通过gdb调试发现if判断后会有一段异常的汇编代码 这里输入的是b’’*4+b’66’，可以看到程序运行到这里是将0xffffffff地址的最后一个字节的数据改成0x66，因为之前分析了code可写，那么可以考虑将put的plt表里的got地址跳转地址修改成system的got地址,可以看看got表的数据 system的got刚好就在putsgot的下面，所以只需要将最后一个字节0x20改成0x24就可 put的plt表中jmp后的got表的最后一个字节为ff需要加2使得最后一个字节为20，改20为24就可 exp "},{"title":"2021_BUUCTF&DASCTF_pwn","date":"2021-05-30T14:35:03.000Z","url":"/2021/05/30/2021-5-30/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PWN：pwnpwn.zip 运行环境为ubuntu18.04，libc-2.27 题目分析不用想保护全开，经典菜单题 菜单有malloc、free、edit、show功能，有一个offbyone漏洞，可以尝试三明治攻击构造两个指向同一块chunk的指针，还有一种方法就是利用overlapping来攻击 方法一思路 先将大小为0x90的tcachebins填满 然后构造0x91（free）—0x90（used）—0x91（used）三明治布局 利用offbyone修改第三个堆块的presize和pre_inuse位，利用unlink得到一个0x1B0大小的堆块包含中间的0x90 将第一个堆块申请出来，通过第二个堆块（used）就可以泄露地址 再申请一个堆块就得到两个指向同一块chunk的指针即第二个堆块 通过攻击tcachebins来写malloc_hook为one_gadget 申请堆块获取shell 坑点 offbyone漏洞一开始没发现，后续仔细分析了一下发现很简单，一开始没静下心来分析 不清楚题目的libc版本，题目只给了libc.so 注意最后一个堆块要额外申请一个小堆块，防止与top chunk合并 题外话：比赛当天有事导致题目没怎么看，准备赛后复现，然后第一道堆题环境是2.23版本的，不太熟悉就没怎么看了，主要是第二道堆题（现在写的），offbyone漏洞一开始没发现，看大佬的博客发现漏洞后（就是当申请的堆块的size的倒数第四位为一，就差不多行了刚好8满足需求）就感觉可以做出了，自己尝试了一下，确实发现没什么难度，这类题目做过类似的所以挺简单的，文章末尾会附上一些大佬的wp和一些例题 exp 方法二思路 构造三个堆块0x21（used）-0x91（used）-0x21（used） 然后利用offbyone修改第二个堆块的大小，使得第二个堆块的大小刚好覆盖第三个堆块（也就是将第二个堆块） 释放第二块堆块，再申请0x91大小的堆块，这样就可以通过第三个堆块泄露地址 再申请一个0x21堆块就得到两个指向同一块chunk的指针即第三个堆块 写free_hook为system地址，释放带有/bin/sh的块获取shell exp 参考博文：    推荐例题： "},{"title":"2021_360CTF_pwn","date":"2021-05-27T14:15:11.000Z","url":"/2021/05/27/2021-5-27/","tags":[["heap","/tags/heap/"],["pwn","/tags/pwn/"],["新手向","/tags/%E6%96%B0%E6%89%8B%E5%90%91/"],["writeup","/tags/writeup/"]],"categories":[["pwn","/categories/pwn/"]],"content":"PWN：lonelysolf题目涉及知识点lonelywolf.zip 先讲讲本次题目所涉及的知识点（我一开始的知识盲区）：tcache_perthread_struct结构体，先看看源代码的样子 可以看到它的结构挺简单的，一个字符数组（tcachebins的计数器）和一个指针数组（最近一次释放的堆指针），然后就是堆初始化的时候申请的第一个chunk就是它。这里写了一个简单的实验，通过调试来理解tcache_perthread_struct结构体的工作方式。 堆调试实验一程序代码： 调试截图（这里程序运行到了释放最后一个chunk的位置）可以看看bin里的内容 再看看堆块的情况，可以看到它的第一个chunk（tcache_perthread_struct结构体）的位置（0x555555559000） 可以看一下tcache_perthread_struct结构体里的内容 这里可以验证字符数组里存放的就是tcachebins的计数器里的值，然后可以看看指针数组里存放的是不是释放后堆块的地址 可以发现指针数组里存放的就是是释放后堆块的地址，通过这个实验可以了解tcache_perthread_struct结构体的管理结构，这个是这次题目的攻击对象，然后在介绍攻击方式：tcachebins里的double free。 这里看看tcachebins链表的结构： 再来看一下free中是怎么处理添加chunk到tcache的，不同于malloc_libc_free对外的接口不直接处理tcache，而是在_int_free这个模块内部例程中处理有关tcache的操作 可以看到这就是tcache的double free检测机制，判断条件就是tcache_entry的key指针（堆块的bk指针位置）是否等于tcache（通过接下来的实验可以发现就是堆初始化的时候申请的第一个chunk的数据地址），这里写了一个简单的tcache的double free的实验。 堆调试实验二程序代码： 这个是第一次free的情况 可以看到tcache_entry的key指针（堆块的bk指针位置）就是堆初始化的时候申请的第一个chunk的数据地址，接下来我们通过填充字节’A’来破坏它 这个是填充字节之后的情况，可以看到bk指针也就是key指针已经被我们修改了，这样的话我们再次释放就可以绕过检测了，接下来可以再次释放就可以达到double free的目的 目的达到，而且这个还是2.31相对高版本的glibc（注：tcache_perthread_struct结构体在2.31版本有些不一样，可以自己通过上面的第一个实验来比较，这里就略过） 题目分析 漏洞分析： 经典的菜单题目，可以看到它我们每次malloc的大小限制到了fastbins范围内，而且每次malloc都会清空上一个的chunk指针（这里限制了我们填充tcachebins的方法），但是free不会清空，这里就有一个UAF漏洞，然后我们的目的是伪造unsortbins（第一个堆块刚好满足条件，而且可以修改tcachebins的计数器），然后free，泄露地址（原理：当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址） 思路有了，先重新构造函数 通过double free达到任意地址读写，同时泄露堆块的地址（用来计算堆初始化的时候第一个chunk的地址，通过第一个chunk达到攻击的目的） 然后就可以修改free chunk的fd指针使其指向堆初始化的时候第一个chunk的地址，然后就可以申请到堆初始化的时候第一个chunk了 要将当前的chunk释放到unsortedbin里，就要先将tcachebins填满，这里可以通过修改第一个堆块的值将tcachebins伪造成满的（根据第一个实验就很容易理解了） 接下来就好办了 exp： 参考博文：   "}]